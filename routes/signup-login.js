var express = require('express');
var mongoose = require('mongoose');
var crypto = require('crypto');  
var router = express.Router();
var app = express();
var http = require('http').Server(app);
var Schema = mongoose.Schema;

var UserSchema = new Schema({
	email: {type: String, unique: true},
	firstname: String,
	lastname: String,
	combined: Buffer,
	roles: Array
});

var UserModel = mongoose.model('users', UserSchema);

router.get('/', function(req, res) {
	console.log("/signup-login");
	if (req.query.login == "true") {
		console.log("/login");
		// the signup and login page differentiation is carried out by the login-main value,
		// and the login value tells whether or not a user is actually logged in
		res.render('signup-login', {"login-main": true, "login": false}); 
	} else {
		console.log("/signup");
	  res.render('signup-login', {"login-main": false, "login": false});
	}
});

router.get('/signup', function(req, res) {
	console.log('signup-login/signup');
	router.signup(req.query.email, req.query.password, req.query.firstname, req.query.lastname, function(err, user) {
		mongoose.connection.close();
		if (user) {
			// regenerate session when signing in
			// to prevent fixation
			req.session.regenerate(function() {
				// store the user's primary key
				// in the session store to be retrieved,
				// or in this case the entire user object
				req.session.user = user;
				req.session.login = true;
				res.json({ status: "success" });
			});
		} else {
			req.session.error = err;
			res.json({ status: err.message });
		}
	});
});


router.connectToDB = function(fn) {
	console.log('connectToDB()');
	var dbURL = '54.187.150.45:27017/chefbox';

	mongoose.connect(dbURL, function(err) {
		if (err) {
			console.log("unable to connect to the mongoDB server. Error:", err);
			fn(err);
		} else {
			console.log("Connection to DB at "+dbURL+" is established");
			fn(null, mongoose);
		}
	});
};

// larger numbers mean better security, less
var config = {
  // size of the generated hash
  hashBytes: 32,
  // larger salt means hashed passwords are more resistant to rainbow table, but
  // you get diminishing returns pretty fast
  saltBytes: 16,
  // more iterations means an attacker has to take longer to brute force an
  // individual password, so larger is better. however, larger also means longer
  // to hash the password. tune so that hashing the password takes about a
  // second
  iterations: 872791
};


router.hash = function(password, callback) {
  // generate a salt for pbkdf2
  crypto.randomBytes(config.saltBytes, function(err, salt) {
    if (err) {
      return callback(err);
    }

    crypto.pbkdf2(password, salt, config.iterations, config.hashBytes,
      function(err, hash) {

      if (err) {
        return callback(err);
      }

      var combined = new Buffer(hash.length + salt.length + 8);

      // include the size of the salt so that we can, during verification,
      // figure out how much of the hash is salt
      combined.writeUInt32BE(salt.length, 0, true);
      // similarly, include the iteration count
      combined.writeUInt32BE(config.iterations, 4, true);

      salt.copy(combined, 8);
      hash.copy(combined, salt.length + 8);
      callback(null, combined);
    });
  });
};

router.signup = function(email, password, firstname, lastname, fn) {
	console.log('signup()');
	/*var mongoose = */router.connectToDB(function(err, mongoose) {
		if (!err) {

			router.hash(password, function(err, combined) {

				if (err) return fn(err);
				//var combined_string = new Buffer(combined, 'binary').toString('hex');
				var data = {
					"firstname": firstname,
					"lastname": lastname,
					"email": email.toUpperCase(),
					"combined": combined,
					"roles": ['normal']
				};
				var user = new UserModel(data);
				user.save(function(err) {
					if (err) {
						console.log("Error creating the user: "+err);
						if (11000 === err.code || 11001 === err.code) {
							fn(new Error('duplicate'));
						} else {
							fn(new Error('failure'));
						}
					} else {
						console.log("Succeeded in creating the user");
						fn(null, user);
					}
				});
			});
		} else {
			fn(err);
		}
	});
};

/**
 * Verify a password using Node's asynchronous pbkdf2 (key derivation) function.
 *
 * Accepts a hash and salt generated by hashPassword, and returns whether the
 * hash matched the password (as a boolean).
 *
 * @param {!String} password
 * @param {!Buffer} combined Buffer containing hash and salt as generated by
 *   hashPassword.
 * @param {!function(?Error, !boolean)}
 */
//router.login = function(password, combined, callback) {
router.login = function(password, email, callback) {
  // extract the salt and hash from the combined buffer
 	console.log('login()');

 	var mongoose = router.connectToDB(function(err, mongoose) {
 		if (!err) {
 			UserModel.findOne({ "email": email }, function(err, user) {

 				if (err) return callback(new Error("mongodb document error"));
 				if (user == null) return callback(new Error("user not found"));

 				var combined = user.combined;
			  var saltBytes = combined.readUInt32BE(0);
			  var hashBytes = combined.length - saltBytes - 8;
			  var iterations = combined.readUInt32BE(4);
			  var salt = combined.slice(8, saltBytes + 8);
			  var hash = combined.toString('binary', saltBytes + 8);

			  // verify the salt and hash against the password
			  crypto.pbkdf2(password, salt, iterations, hashBytes, function(err, verify) {

			    if (err) return callback(err);
			    if (verify.toString('binary') === hash) return callback(null, user);
			    return callback(new Error('incorrect password')); 
			  });
			});
 		}
 	});
};

router.get('/login', function(req, res) {
	console.log('signup-login/login');

	router.login(req.query.password, req.query.email.toUpperCase(), function(err, user) {
		mongoose.connection.close();

		if (!err) {
			// regenerate session when signing in
			// to prevent fixation

			req.session.regenerate(function() {
				// store the user's primary key
				// in the session store to be retrieved,
				// or in this case the entire user object
				req.session.user = user;
				req.session.login = true;
				res.json({ status: "success" });
			});
		} else {
			console.log(err.message);
			req.session.error = err;
			res.json({ status: err.message });
		}
	});
});

router.get('/logout', function(req, res) {
	console.log('signup-login/logout');
	req.session.destroy(function() {
		res.redirect('/');
	});
});

module.exports = router;